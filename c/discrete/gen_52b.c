/* gen_52b.f -- translated by f2c.  
    Following C custom, the main routine---implicit_edits---is last in the file.  */

#include <apop.h>
#include "internal.h"
#define FALSE_ 0
#define TRUE_ 1

extern int nflds, edit_ct, verbose;
extern int *find_b, *find_e;
extern apop_data *edit_grid;
int ndatpt;

/*  
nflds = no. of fields 
edit_ct (formerly nexp) = no. of specified edits 
em = int array of complete set of edits 
ii_edits: (previous level implied edits). stores zero-offset info
ir_edits: root of implicit edit searches, I think.  stores zero-offset info
n_edits: zero-offset throughout; count of implicit edits (I think)
dptr: "Tracks freed storage." I.e. lists dominated edits that can be ignored and removed.
stk: ???. stores zero-offset info
llink: "maintains stack of edits in cover"
s_pth: search paths (along fields). 1=eliminated, 0=still a candidate

abcmat: subset of codmat still uncovered.  abcmat has abcmat_rows rows and abcmat_cols cols.
rptr: rptr(l) = .f. implies row l is to be excluded from abcmat(,)
llptr: is index of the edit corresponding to abcmat.  
      To recover orig edits use ptr() array

e_node: rows=edit count, cols= # of fields. (i,j)=True iff field j enters into edit i.

ptr: Broadly: ptr[0] is the first row of e_node where field i enters, so this basically
    compacts the potentially sparse e_node matrix to a list of indices that matter. 
    zero-offset range; zero-offset contents.
But: the counter is reset for each field. If field 0 marks down five rows of e_node, 
    then field 1 marks down three, then ptr[0] to ptr[2] refers to field 1; ptr[3] and 
    ptr[4] refer to field 0.
*/

/*These guys are global to this file, because there's no reason why they
shouldn't be: it's a sequential file where all varnames stay the
same from fn to fn. Also, it makes the realloc_party a lot easier.*/ 
gsl_matrix *e_node, *abcmat, *ii_edits, *ir_edits, *codmat, *s_nodes;
int *inr_edits, *dptr, *cptr, *rptr, *lptr, initial_edit_ct;

static void stretch_one_matrix(gsl_matrix **m){
    *m = apop_matrix_realloc(*m, edit_ct, (*m)->size2);
    Apop_matrix_row(*m, edit_ct-1, a_row);
    gsl_vector_set_all(a_row, 0);
}

static void stretch_one_vector(int **v){ *v = realloc(*v, sizeof(int)*edit_ct); (*v)[edit_ct-1]=0; }

static void realloc_party(){
    gsl_matrix **mlist[]={&edit_grid->matrix, &abcmat, &e_node, &ii_edits,
                            &ir_edits, &codmat, &s_nodes, NULL};
    for(int ctr=0; mlist[ctr]; ctr++)
        stretch_one_matrix(mlist[ctr]);
    int **vlist[]={&lptr, &rptr, &cptr, &dptr, NULL};
    for(int ctr=0; vlist[ctr]; ctr++)
        stretch_one_vector(vlist[ctr]);
}

    /*      w e winkler  960801 9p */
static void testw(int *restrict m, int *restrict newgen, int *restrict newed, int field_index, 
        int *restrict newed_location, int *restrict i_pass, int *restrict n_edits) {
    static int i2, add;

    *newed_location = -1;
    *newed = FALSE_;
/*       Test to see if gen fld is uninvolved in new edit */
    for (int ctr = find_b[field_index]-1; ctr < find_e[field_index]; ++ctr)
        if (!newgen[ctr]) 
            return; //Fld i enters edit newgen; newgen is thus not essentially new 

/*        Test if any fld of new edit contains 'F' only */
    for (int i = 0; i < nflds; ++i) {
        int all_f = 1;
        for (int i3 = find_b[i]-1; all_f && i3 < find_e[i]; ++i3) 
            if (newgen[i3]) 
                all_f = 0;
        if (all_f) // At least 1 fld of newgen is all .F.; newgen is not an edit.
            return;
    }

    /* Check if new edit is redundant to some existing edit 
       also check if equal existing edit and generated by fewer edits */
    for (int i = 0; i < *m; ++i) {
        for (int i3 = 0; i3 < ndatpt; ++i3) 
            if (newgen[i3] && !apop_data_get(edit_grid, i, i3))
                goto L30;
        // edit is strictly redundant
        for (int i3 = 0; i3 < ndatpt; ++i3)
            if (newgen[i3] != apop_data_get(edit_grid, i, i3)) 
                return;
        // edit is the same, check if n_edits gt (top+k1) 
        if (*i_pass < n_edits[i]) {
            assert(i < edit_ct);
            *newed_location = i;
            *newed = TRUE_;
        }
        return;
    L30:
        ;
    }

    /* If edit is new, check to see if it contains any existing edit  */
    *newed = TRUE_;
    for (i2 = 0; i2 < *m; ++i2) {
        assert(i2 < edit_ct);
        if (dptr[i2]) 
            goto L40;
        for (int i3 = 0; i3 < ndatpt; ++i3)
            if (apop_data_get(edit_grid, i2, i3) && ! newgen[i3]) 
                goto L40;

        /*  edit i2 of edit_grid->matrix(,) is dominated by newgen; set dptr(i2) to .t. 
            to take note of domination.  Add counts dominated edits. */
        dptr[i2] = TRUE_;
        ++add;
    L40:
        ;
    }

    /* The system used to use dptr to find dominated edits, then overwrite there.
       But the em matrix won't get anywhere near filling memory, and since this isn't
       FORTRAN `77, we can reallocate. So always add to the end of the em matrix. */
    //note: the # of edits has changed on account of additions and possibly deletions. 
    *newed_location = i2;
    *m = i2+1;
    edit_ct ++;
    realloc_party();
    if (verbose)
        printf("adding implicit edit; up to %i edits total.\n", edit_ct);
    for (int i3 = 0; i3 < ndatpt; ++i3)
        apop_data_set(edit_grid, i2, i3, newgen[i3]);
} /* testw */

void check_for_new_edits(int newed_location, int edit_ct, int *implicit_ct){
    if (newed_location >= edit_ct) {
        ++(*implicit_ct);
        printf(".%i\t", (unsigned int) *implicit_ct);
    }
}

void init_link_list(int *restrict lnk, int abcmat_cols){
        for (int i = 0; i < abcmat_cols; ++i) 
            lnk[i] = i + 1;
        lnk[abcmat_cols] = -1;
}

/*       history: w winkler  960729 6p 
       at root nodes, must always find at least one cover 
        updates to dptr()-tracking released storage 
        s_nodes(), e_nodes()  are not presently in 
        sync with i_edits that is used in nr_covw 
       abcmat(,) is an abbrev of codmat after unit vector columns have 
       been removed. gened() and newgen() are used to generate new edit, if any. 
       rptr() and cptr() are pointers to the rows and columns of codmat 
       and/or abcmat(,) as the context demands. */

/*     First identify unit vectors that are part of cover.
       If a fld is only covered by one edit, then that edit must be part of every cover.
       All other fields covered by unit vectors are automatically covered.  
       Every cover must include all unit cover vectors.

       f_pass controls new implicit edit generation when r_cov is being called from within nr_covw.*/
static void root_coverings(int *restrict m, int *restrict newed, int *restrict lt, int i__, 
    int *restrict ptr, int *restrict n_edits, int *restrict implicit_ct, int this_root,
    int *restrict rlink, int *restrict llink, int *restrict stk, int f_pass) {

    static int i1, i2, k1, abcmat_cols, m1, n1, new_top, abcmat_rows, m4, kh, mt, newed_location, 
                top, current_edit, i_gen, itemp, i_pass, testg, newed2, testg2, field_len;
    static int  *llptr, *lnk,
                *gened,//zero-one
                *newgen; //subset of gened
    if (!lnk){
        lnk = calloc(edit_ct, sizeof(int));
        llptr = calloc(edit_ct, sizeof(int));
        gened = calloc(ndatpt, sizeof(int));
        newgen = calloc(ndatpt, sizeof(int));
    }

    if (f_pass) {
        *implicit_ct = 0;
        f_pass = FALSE_;
    }
    i_gen = i__+1;
    for (int k = 0; k < edit_ct; ++k) {
        rptr[k] = TRUE_;
        cptr[k] = TRUE_;
    }
    field_len = find_e[i__] - find_b[i__]+1;
    *newed = FALSE_;
    newed2 = FALSE_;

    // Find unit vector cover, check if any cover is possible
    k1 = 0;
    for (int l = 0; l < field_len; ++l) {
        /* col pointer of cols cover by a row which is unit vector 
           cover of any one of those columns is set to .f. */
        if (!cptr[l]) 
            continue;
        m1 = 0;
        abcmat_cols = 0;
        for (int index = 0; index < *lt; ++index) 
            if (gsl_matrix_get(codmat, index, l)) {//row index does not cover column l 
                ++m1;
                abcmat_cols = index+1;
                if (m1 > 1) // More than 1 row covers col l --> l not unit vect cover
                    goto L20;
            }

        if (abcmat_cols == 0) //a col of codmat is a null vector; no cover possible; return
            return;
    // A unit vector cover has been found.  row # is abcmat_cols.
        rptr[abcmat_cols-1] = FALSE_;
        ++k1;

        lptr[k1-1] = abcmat_cols;          //lptr(x) points to the x'th unit vector covering row.
        for (int l2 = 0; l2 < field_len; ++l2) //set cptr of cols covered by row abcmat_cols to false 
            if (gsl_matrix_get(codmat, abcmat_cols-1, l2)) 
                cptr[l2] = FALSE_;
    L20:
        ;
    }

		/*   At this stage, rows of codmat uninvolved in all prime covers are
		identified and rprt() of such rows and cprt() of cols that are covered
		set to .f. Using this info an abbrev code matrix is constructed. Need
		only search abcmat to get the prime cover.  Using field i as generating
		field generate an 'edit' using the edits referenced by lptr(). */
    for (int i = 0; i < ndatpt; ++i)
        gened[i] = TRUE_;
    for (int i = find_b[i__]-1; i < find_e[i__]; ++i)
        gened[i] = FALSE_;
/*       there might not have been a unit vector column. */
    if (k1 != 0) {
        /* Generate the edit implied by the unit vector covers. 
           lptr() indexes the edit in codmat(,); The index of this index, 
           which ptr() indexes, is the true index of the edit in subem(,) 
           BK rewrite: lptr's indices are apropos for codmat; ptr's translates from those
           values to values apropos for em.
         */
        kh = 0;
        for (int i1 = 0; i1 < k1; ++i1) {
            i2 = ptr[lptr[i1]-1];
            if (n_edits[i2] > 1) 
                kh = kh + n_edits[i2] - 1;
            for (int i3 = 0; i3 < ndatpt; ++i3) 
                if (i3 >= find_b[i__]-1 && i3 <= find_e[i__])
                    gened[i3] = gened[i3] || apop_data_get(edit_grid, i2, i3);
                else
                    gened[i3] = gened[i3] && apop_data_get(edit_grid, i2, i3);
        }
    }

    /*     Construction of abcmat - subset of codmat still uncovered. */
    /*     this section requires major! modification */
    abcmat_rows = 0;
    for (int l = 0; l < *lt; ++l) {
        if (rptr[l]){//rptr(l) = .f. implies row l is to be excluded from abcmat(,) */
            abcmat_cols = 0;
            assert(l < edit_ct);
            llptr[abcmat_rows] = l;
            // If cptr(t) = .f. then unit vector cover already covers this col 
            for (int ell = 0; ell < field_len; ++ell)
                if (cptr[ell]){
                    gsl_matrix_set(abcmat, abcmat_rows, abcmat_cols, 
                           gsl_matrix_get(codmat, l, ell));
                    ++abcmat_cols;
                }
            ++abcmat_rows;
        }
    }
    if (abcmat_rows == 0 || abcmat_cols == 0) {
        /* If abcmat(,) has 0 rows and/or columns, check if gened() is essentially new.
           0 columns means prime cover.  If new edit, then it must be maximal.  
           All other edits would be redundant; hence, return immediately after tester() */
        i_pass = k1 + kh;
        testw(m, gened, &newed2, i__, &newed_location, &i_pass, n_edits);

        if (newed2) {
            *newed = TRUE_;
            n_edits[newed_location] = k1;
            /*    keep track of storage locations of newly implied edits */
            check_for_new_edits(newed_location, edit_ct, implicit_ct);
            if (newed_location != -1) {
                for (int i1 = 0; i1 < nflds; ++i1) 
                    gsl_matrix_set(s_nodes, newed_location, i1, 
                            (this_root>0) ? gsl_matrix_get(s_nodes,this_root, i1): FALSE_);
                gsl_matrix_set(s_nodes, newed_location, i_gen-1, TRUE_);
                n_edits[newed_location] = i_pass;
            }
        }
        // Any new edit must necessarily be the only maximal one possible.
        return;
    }

/*    beginning of main loop. */
/*    Tree structure for finding "all" prime cover solutions is similar to tree structure in fldcod. */
    if (this_root > 0) {
        testg = FALSE_;
        for (int i1 = 0; i1 < k1; ++i1) {
            i2 = ptr[lptr[i1]-1];
            if (i2 == this_root-1) {
                testg = TRUE_;
                break;
            }
        }
    } else 
        testg = TRUE_;

    for (int m1 = 0; m1 < abcmat_rows; ++m1) {
        top = 0;
        /*   Linked list of cols which remain to be covered via lnk() 
             To begin with all cols of abcmat are uncovered.
             So each element initially just points to the next, and last is a sentinel. */
        init_link_list(lnk, abcmat_cols);
        n1 = m1; //n1 will keep growing
        assert(n1 < edit_ct && n1 >=0);

        /*    construct a  cover solution.
            *** note *** even though a prime cover solution is required, if a redundant 
            cover is constructed and used in the edit generation no generality is lost. 
            Trade off is between testing if the cover generated is prime and the cost of 
            generating an edit which is nonprime; latter is usually less expensive. */

        /*  cover construction always starts at n1 */
        /*  current_edit is only updated via llink() */
        /*   update; llink() maintains stack of edits in cover */
        new_top = 0;
        current_edit = n1+1;
        while(1){
    printf("94\n");
            while (1){
                itemp = 0;
                while((m4 = lnk[itemp]) != -1)
                   if (n1 < edit_ct && !gsl_matrix_get(abcmat,n1, m4-1))
                       itemp = m4;
                   else {
                       /*        i.e. n1 doesn't cover field pointed to by m4 */
                       /*        if it does then adjust the list to reflect this. */
                       lnk[itemp] = lnk[m4];
            printf("%i: %i %i\n", __LINE__, itemp, lnk[itemp]);
                       new_top = 1;
                   }
                if (new_top){
                    assert(n1 < edit_ct);
                    stk[top++] = n1;
                    if (n1+2 < abcmat_rows) 
                        rlink[n1] = -1;
                    if (n1+2 == abcmat_rows) 
                        rlink[n1] = 0;
                    if (current_edit != n1+1) {
                        assert(n1 < edit_ct);
                        llink[current_edit-1] = n1; 
                    }
                    current_edit = n1+1;
    printf("%i: lnk[0] %i top %i\n", __LINE__, lnk[0], top);
                    if (lnk[0] == -1)
                        break;
                    /*   lnk() points to noncovered fld vals, lnk(0)=-1 -> all covered */
                    /*  i.e. At extremity of a subtree without a cover;  backtrack */
                }
                ++n1;
                assert(n1 < edit_ct && n1 >=0);
                if (n1+1 > abcmat_rows)
                    goto L140;
                new_top = 0;
            }

        /*   generation of a new edit. First step: recover the edits that h 
             participated in the prime cover(as unit vector covers) */
            int gogogo;
            do{
                for (mt = 0; mt < ndatpt; ++mt)
                    newgen[mt] = gened[mt];
                testg2 = testg;
                kh = 0;
                for (itemp=top-1; itemp>-1; itemp--){//step through edits in the cover. BK: Not sure why it steps backward.
                    assert(stk[itemp] < edit_ct);
                    assert(llptr[stk[itemp]] < edit_ct);
                    assert(ptr[llptr[stk[itemp]]] < edit_grid->matrix->size1);
                    i1 = ptr[llptr[stk[itemp]]];
                    if (n_edits[i2] > 1) 
                        kh = kh + n_edits[i2] - 1;
                    if (this_root > -1 && ! testg2 && i1 == this_root) 
                        testg2 = TRUE_;
                    for (i2 = 0; i2 < ndatpt; ++i2) 
                        if (i2 >= find_b[i__]-1 && i2 <= find_e[i__]) 
                            newgen[i2] = newgen[i2] || apop_data_get(edit_grid, i1, i2);
                        else
                            newgen[i2] = newgen[i2] && apop_data_get(edit_grid, i1, i2);
                }
                if (testg2){
                    i1 = *m;
                    /* An edit has been created using cover edits. */
                    /* Check if this edit is essentially new. */
                    i_pass = k1 + top + kh;
                    testw(m, newgen, &newed2, i__, &newed_location, &i_pass, n_edits);
                    if (newed2) {
                        newed2 = FALSE_;
                        *newed = TRUE_;
                        /*        all unit vectors covers & additional ones */
                        check_for_new_edits(newed_location, edit_ct, implicit_ct);
                        if (newed_location != -1) {
                                for (int i1 = 0; i1 < nflds; ++i1) 
                                    gsl_matrix_set(s_nodes,newed_location, i1,
                                        (this_root>0) ? gsl_matrix_get(s_nodes,this_root, i1) : 0);
                            gsl_matrix_set(s_nodes,newed_location, i_gen-1, FALSE_);
                            n_edits[newed_location] = i_pass;
                        }
                    }
                }
            /* new edit may not be only maximal one 
               edit matrix em(,) has been updated. Need to look for other possible "prime" covers. */
            L140:
                if (!(n1+1 < abcmat_rows) && (top != 2)){
                    if (top <= 1 && n1 > abcmat_rows) //i.e. not at the extremity of a subtree
                        goto L200;
                    /*       i.e. Current subtree exhausted; go to next one, if any. */
                    --top;
                }
                do {
                    --top;
                    if (top < 1) 
                        goto L200;  //break from all loops but the main for().
                    n1 = stk[top-1];
                    assert(n1 < edit_ct);
                    itemp = llink[n1];
                } while (rlink[n1] == 0);
                /*        i.e. already scanned this subtree */
                llink[n1] = itemp+1;
        printf("%i: n1 %i llink[n1] %i\n", __LINE__, n1, itemp+1);
                if (llink[n1]+1 == abcmat_rows) // if llink()=abcmat_rows then there are no more branches to scan from here.
                    rlink[n1] = 0;
                if (llink[n1] < abcmat_rows) 
                    rlink[n1] = -1;

                /*re-*/init_link_list(lnk, abcmat_cols);

                // construction of prime cover soln at non root node.
                gogogo = 0;
                for (int ii=0; ii < top; ii++) {
                    n1 = stk[ii];
            assert(n1 < edit_ct && n1 >=0);
                    m4 = 0;
                    itemp = m4;
                    while ((m4 = lnk[itemp]) != -1)
                        if (!gsl_matrix_get(abcmat, n1, (m4 - 1)))
                            itemp = m4;
                        else
                            lnk[itemp] = lnk[m4];
                    if (lnk[0] == -1) {
                        gogogo=1; break;            
                    } /*       i.e. A new prime cover soln generated. */
                }
            } while(gogogo);
            // Prime cover not found; need to grow the tree some more.
            current_edit = n1+1;
            n1 = llink[n1];
        assert(n1 < edit_ct && n1 >=0);
            new_top = 0;
        }
    L200:
        ;
    }
    /*    All prime cover solns have been looked at. Time to return */
} /* root_coverings */

void copy_one_var(int mx, int my, int f_row, int em_row){
  int cod_col = 0;
    for (int j = mx-1; j < my; ++j, ++cod_col)
        gsl_matrix_set(codmat, f_row-1, cod_col, 
                apop_data_get(edit_grid, em_row-1, j));
}

//This was redundant code, so I (BK) broke it out into a function, but
//I'm frankly not quite clear what it does.
void business(int *restrict i__, int i_p__, int *restrict rlink, int *restrict llink, 
      int i_chk, int *restrict k_end, int *restrict s_pth, int *restrict f_pass, 
      int *restrict n_ii__, int *restrict in_edits){
    // assure that i_chk is not an eliminated search path 
    while (s_pth[i_chk]) {
        i_chk = (i_chk+1) % nflds;
        if (i_chk == *i__)
            return;             //BK---this shouldn't happen. It means there's no path to search
    }
    llink[*i__] = i_chk;
    /*       If next node is the last in the last of flds, then there */
    /*        are other branches left from the current node. */
    rlink[*i__] =  -(llink[*i__] != k_end[i_p__]); //rlink== 0 or -1.
    /*       Set current fld # to next fld down the tree. */
    *i__ = llink[*i__-1];
    // go back to generate codmat afresh at new node i. 
        /*     each time tree is grown or shrunk, f_pass set to true */
    *f_pass = TRUE_;
    *n_ii__ = in_edits[i_p__];
}

/*      get implied edits at nonroot nodes 
        w e winkler  960918 1p 
     i_edits() contains edits from root node i=i_p being processed 
     ir_edits() contains needed information about implicit edits 
      that can be generated at all nodes.  Most nonproductive 
      computation is done at root nodes.  To find implicit edits 
      at nonroot nodes, we can use the info that was obtained at root 
      nodes.  Specifically, if we are generating at node (ij), then 
      for each root node i implicit edit, we look at successive root 
      node j implicit edits.  For each 

    A new edit has been generated.  Look at rest of tree. 
      Stack current node and proceed down the tree.
      lll is root node implied edit being processed, initially ll 
      points to it, later to most recently generated implied edit 
      stk() keeps track of levels in tree being processed. 
      ii_edit(i,.) keeps track of implied edits at level i ( stk(top)=i ) 
      Only time statement 6 reached is when new implied edits are generated 
      if no root node i implicit, then there will be no nonroot node i 
       edits and the search path can be eliminated.  */
static void nr_covw__(int *restrict m, int *restrict newed, int *restrict lt, 
        int i__, int *restrict ptr, int *restrict stk, int *restrict rlink, 
        int *restrict llink, int *restrict n_edits, int *restrict implicit_ct) {

    int in_edits[nflds], i0, j0, k0, k1, m1, jj, ll, mx, my, i_p__, n_ii__, topn, itemp,
       k_endh, ed_stk[nflds], gen_flg, test, g_used[edit_ct], f_pass, k_end[nflds], k_gen, k_imp;
    static int *s_pth;
    if (!s_pth) s_pth = malloc(nflds* sizeof(int));

    for (int j = 0; j < nflds; ++j) {
        k_end[j] = 0;
        s_pth[j] = (inr_edits[j] == 0);
    }
/*      move root nodes implicit edits to storage of this subroutine */
    n_ii__ = inr_edits[i__];
    for (k1 = 0; k1 < n_ii__; ++k1) 
        gsl_matrix_set(ii_edits, k1, i__, gsl_matrix_get(ir_edits, k1, i__));
    in_edits[i__] = n_ii__;
    *implicit_ct = 0;
    topn = -1;
    while (1){ //mega-loop
        ++topn;
assert(topn < edit_ct);
        stk[topn] = i__; 
assert(topn < edit_ct);
        s_pth[i__] = TRUE_;
        i_p__ = i__;
        if (i__ > 0) 
            k_endh = i__-1;
        else
            k_endh = nflds-1;
        /*    assure that k_endh is not an eliminated search path */
        /*     if k_endh exists, can do further searching */
    L8:
        if (s_pth[k_endh]) {
            k_endh = (k_endh-1) % nflds;
            if (k_endh != i__) 
                goto L8;
            else 
                /*      all search paths have been eliminated, should not hit this part */
                /*        this is a double-check, goto where stk() is decremented. */
                break; //from mega-loop
        }
        k_end[i_p__] = k_endh;
    /*      tree expanded - new implicit edits to storage of this subroutine */
    /*       add 2nd or lower nonroot node - first-level done above */
        if (i__ != stk[0]) {
            n_ii__ = *implicit_ct;
            *implicit_ct = 0;
            for (k1 = 0; k1 < n_ii__; ++k1) 
                gsl_matrix_set(ii_edits, k1,i__, initial_edit_ct+k1);
            in_edits[i__] = n_ii__;
        }

        /*  Set left link of current node to next node (at this point one is guaranteed).
            If no more nodes need to be examined subsequent to current node then 
            rlink = 0; otherwise = -1. 
            assure that i_chk is not an eliminated search path */
        business(&i__, i_p__, rlink, llink, /*i_chk=*/(i__ % nflds), k_end, s_pth, &f_pass, &n_ii__, in_edits);

        /*    Generation of codmat and iteration at a nonroot node.
              only need one implied edit & orig edits 
              info for tracking generated edits 
              make multiple (n_ii) passes thru r_cov() 
              when enter this portion r_cov returns i_edits which must be 
              held in ii_edits (previous level implied edits) and used. */
    L14:
        k1 = 1;
    /*       use next implied edit from previous level */
    L18:
        ll = gsl_matrix_get(ii_edits, k1-1, i_p__);
        *lt = 0;
    /*       if invalid search direction, go to next search direction */
        if (gsl_matrix_get(s_nodes, ll, i__)) {
            if (k1 < n_ii__) {
                ++k1;
                goto L18;
            } else 
                goto L80;
        }
    /*       also check if entering field */
        test = TRUE_;
        mx = find_b[i__];
        my = find_e[i__];
        for (m1 = mx; test && m1 <= my; ++m1) 
            if (!apop_data_get(edit_grid, ll, m1-1))
                test = FALSE_; /*       field i enters edit ll */
        if (test){ /* If at this point, then field i does not enter edit ll */
            if (k1 < n_ii__) {
                ++k1;
                goto L18;
            } else 
                goto L80;
        }
    /*   now use implicit edits that were generated at root node i 
         these help us drastically reduce computation 
        look at root-i implicit edit ell, make sure fields from stack 
         stk() do not enter to eliminate.  use all but one of explicit 
         edits used in generating ell plus implicit edit ll to generate 
         new implicit edits 
          26 continue loop - root node-i edits combined with ll 
           k0 is incremented until it exceeds k_imp 
         first assure that at least k_gen-1 available */
        memset (g_used, 0, sizeof(int)*edit_ct);//i.e. set all g_used to zero
        k_imp = inr_edits[i__];
        k0 = 1;
    L26:
        k_gen = n_edits[(int) gsl_matrix_get(ir_edits, k0-1, i__)];
        i0 = 1;
        gen_flg = 0;
        j0 = 0;
        for (int j = 0; j < edit_ct; ++j) {
assert(topn < edit_ct);
            for (int jj = 0; jj <= topn; ++jj) 
                if (gsl_matrix_get(e_node, j, stk[jj])) //  if field stk[jj] enters explicit edit j,  bypass 
                    goto L32;
            ++j0;   //      add edit j to ed_stk() 
            ed_stk[j0 - 1] = j+1;
            L32:
            ;
        }
        jj = k_gen - 1;
        if (j0 <= jj)  //at most one edit can be generated 
            gen_flg = 1;
        else if (j0 == k_gen)  //at most k_gen edits can be generated 
            gen_flg = 2;
        else if (k0 < k_imp) { //determine if another edit can be generated at this level
            ++k0;
            goto L26;
        }
    /*       Need to look at each edit for each field */
    /*       Only need to process orig edits */
    /*     110 loop determines those orig edits being considered in codmat() */

    /*     If reach this point, then there is at least one additional edit */
    /*      that can be used in generating new implied edits.  First row */
    /*      in codmat() is edit ll */

        if (*lt == 0) {
            *lt = 1;
            assert(ll <edit_grid->matrix->size1);
            ptr[*lt-1] = ll;
            copy_one_var(mx, my, /*row to fill=*/*lt, /*em_row*/ll+1);
        }
        if (*lt > 1) 
            *lt = 1;
    L48:
        if (gen_flg != 0)
            for (jj = 1; jj <= j0; ++jj) {
                if (gen_flg == 2 && jj == i0)
                    continue;
                //else:
                ++(*lt);
                int ell = ed_stk[jj - 1];
                ptr[*lt-1] = ell-1;
                copy_one_var(mx, my, *lt, ell);
            }
    /*  search() indicates whether further search can be done 
        s_nodes() indicates which directions searches can take place 
        implicit_ct indicate number of any new implied edits */
        *newed = FALSE_;
        if (*lt == 2){
            if (g_used[ptr[1]])
                goto L70;
            else
                g_used[ptr[1]] = TRUE_;
        }
        root_coverings(m, newed, lt, i__, ptr, n_edits, implicit_ct, ll+1, NULL, NULL, NULL, f_pass);

    L70:
        if (gen_flg == 2 && i0 < j0) { //need to generate using the same i-node set from edit k0 
            ++i0;
            *lt = 1;
            goto L48;
        }
        if (k0 < k_imp) { //have not processed all i-node edits (from roots)
            ++k0;
            goto L26;
        }
    L80:
    /*       check whether additional implied edits at this level must be considered */
        if (k1 < n_ii__) {
            ++k1;
            goto L18;
        }
        if (k1 == n_ii__ && *implicit_ct == 0) //backtrack - at extremity of subtree or no new edit 
            break;
        /*  at this point, a new edit has been found and we are at a non root node. 
            if reach this point, then have processed all implied edits at a given level. 
            if not at the very end of stack, proceed to next level & add to stk(). */
    } //mega-loop
    /*        back tracking segment */
    /*         if at extremity of a subtree need to backtrack two levels */
    if (k1 < n_ii__) {
        ++k1;
        goto L18;
    }
    if (i__ == k_end[i_p__]) {
        s_pth[stk[topn]] = FALSE_;
        --topn;
assert(topn < edit_ct);
    /*       if stack pointer is at bottom of stack goto next subtree */
        if (topn <= 0) 
            return;
    }
    while(1){
        i__ = stk[topn];
        i_p__ = i__;
        itemp = llink[i__]+1;
        /*       if there is no branch to be processed at node i go down one more */
        if (rlink[i__-1] != 0) {
            // assure that i_chk is not an eliminated search path 
            business(&i__, i_p__, rlink, llink, /*i_chk=*/(itemp % nflds), k_end, s_pth, 
                                                &f_pass, &n_ii__, in_edits);
            n_ii__ = in_edits[i_p__];
            goto L14;
        }
        s_pth[stk[topn]] = FALSE_;
        --topn;
        // if a subtree has been exhausted, go to the next subtree.
        if (topn < 0) 
            return;
    }
} /* nr_covw__ */

//Variable length arrays have no initialization tricks at their disposal.
void init_vla(int *restrict in, int len){for (int i=0; i< len;i++) in[i]=0;}

/*     g52b.for    w e winkler   970412  1p */
/*     also folded in:  setup for main subroutines that get covers */
/*        w e winkler  960917 4p */
void implicit_edits(void) {
 return;
    ndatpt = total_option_ct;
    int test, newed, m=0, lt=0, implicit_ct, stk[edit_ct], 
        ptr[edit_ct], llink[edit_ct], rlink[edit_ct], n_edits[edit_ct];
	inr_edits = calloc(nflds, sizeof(int));
	cptr = calloc(edit_ct, sizeof(int));
	rptr = calloc(edit_ct, sizeof(int));//true-false
	lptr = calloc(edit_ct, sizeof(int));//true-false
	dptr = calloc(edit_ct, sizeof(int));
    init_vla(stk, edit_ct);   // one-offset contents; zero-offset in root_coverings
    init_vla(ptr, edit_ct);   // zero-offset contents; zero-offset in root_coverings
    init_vla(llink, edit_ct);
    init_vla(rlink, edit_ct);
    init_vla(n_edits, edit_ct); 
    e_node = gsl_matrix_calloc(edit_ct, nflds);
    s_nodes = gsl_matrix_calloc(edit_ct, nflds);
    abcmat = gsl_matrix_calloc(edit_ct, ndatpt);
    ii_edits = gsl_matrix_calloc(edit_ct, nflds);
    ir_edits = gsl_matrix_calloc(edit_ct, nflds);
    codmat = gsl_matrix_calloc(edit_ct, ndatpt);

/*From back when there were pre-compiled limits on everything, here they were:
      parameter (mxeds=2500,mxsize=100,ndatpt=442,nexp=518,nflds=84) */

    m = edit_ct;
    initial_edit_ct = edit_ct;
/*      initialize entering node indicator info */
    gsl_matrix_set_all(e_node, FALSE_);
/*      entering node info is used many times */
    for (int j = 0; j < nflds; ++j)
        for (int jj = 0; jj < edit_ct; ++jj) {
            test = TRUE_;
            for (int m1 = find_b[j]; m1 <= find_e[j]; ++m1) {
                test = test && apop_data_get(edit_grid, jj, m1-1);
    /*          field j enters edit jj */
                if (! test) {
                    gsl_matrix_set(e_node, jj, j, TRUE_); //after this, e_node is read-only
                    break;
                }
            }
        }
    // Get ready to find implicit edits generated at root nodes
    for (int j = 0; j < nflds; ++j){
		int is_field_head = 0;
		for (int i = 0; i < nflds && !is_field_head; ++i) 
			if (j == find_b[i])
				is_field_head++;
        if (!is_field_head) {
            lt = 0;
            // transfer entering field info to matrix used in locating covers
            for (int jj = 0; jj < edit_ct; ++jj) {
                if (gsl_matrix_get(e_node, jj, j)) {
                    ptr[lt] = jj;
                    ++lt;
                    copy_one_var(find_b[j], find_e[j], lt, jj+1);
                }
            }
            // find new implied edits at various root nodes, ll=0 root node 
            newed = FALSE_;
            root_coverings(&m, &newed, &lt, j, ptr, n_edits, &implicit_ct, 
                    /*this_root=*/0, rlink, llink, stk, /*fpass=*/1);
            for (int k1 = 0; k1 < implicit_ct; ++k1)
                gsl_matrix_set(ir_edits,k1, j, initial_edit_ct+k1); //BK --?
			inr_edits[j] = implicit_ct;
        }
	}
    /*      eventually have loop go up to nflds */
    for (int j = 0; j < nflds; ++j) {
        implicit_ct = inr_edits[j];
        nr_covw__(&m, &newed, &lt, /*i__=*/j, ptr,stk, rlink, llink, n_edits, &implicit_ct);
    }

    /*
    // Adjust storage for dptr() - dominated edits
    // Use Apophenia's column-cutting utility to cut rows (which means two transpose steps)
    apop_data *cut_me =apop_data_alloc(0, edit_grid->matrix->size2, edit_grid->matrix->size1);
    gsl_matrix_transpose_memcpy(cut_me->matrix, edit_grid->matrix);
    apop_data_rm_columns(cut_me, dptr);
    gsl_matrix_transpose_memcpy(edit_grid->matrix, cut_me->matrix);
    apop_data_free(cut_me);
    */
}
